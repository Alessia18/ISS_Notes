\chapter{Authentication techniques and architectures}

\section{What is authentication}


\subsection*{Definitions of authentication}
There are three different definitions of \emph{authentication:}
\begin{itemize}
  \item \textbf{RGC-4949 (Internet security glossary)}:\\
        "the process of verifying a claim that a system entity or system
        resource has a certain attribute value"
  \item \textbf{\url{whatis.com}}:\\
        "the process of determining whether someone or something is
        who or what it is declared to be"
  \item \textbf{NIST IR 7298 (Glossary of Key Information Security Terms)}:\\
        "verifying the identity of a user, process, or device, often as a
        prerequisite to allowing access to resources in an information
        system"
\end{itemize}
The key aspects of these definitions  are that they define the authentication of an actor, meaning that \textbf{it could be not only a human being} (interacting via software running on hardware) \textbf{but also a software component or a hardware element} (interacting via software). The common shorthand for authentication is \texttt{authN} or \texttt{authC}, while \texttt{authZ} is used for authorization, \textit{which is different but related}.
% Maybe add a cross-reference to "different but related", idk to what yet


\subsection*{Authentication factors}
While authenticating an \emph{actor}, there are three categories of \textbf{authentication factors} that can be used:
\begin{itemize}
  \item \textbf{Knowledge}: authentication relies on something that \emph{only the user knows}, for example a static
        passphrase, code, or personal identification number.\\
        The associated risks involve the storage of this
        knowledge, how it can be demonstrated, and the way it is transmitted.
  \item \textbf{Ownership}: authentication relies on something that \emph{only the user possesses} (often called an
        "authenticator"), for example, a token, smart card, or smartphone.\\
        The associated risks can be related
        to the authenticator itself, such as the possibility of infection with malware, the potential for it to be
        manufactured in a country that imposes government control, or the risk of it being stolen, cloned, or
        used without the owner's authorization (e.g., forgetting an unlocked smartphone).
  \item \textbf{Inherence}: \emph{something the user is}, for example, a biometric characteristic (such as a fingerprint).\\
        The associated risks include counterfeiting and privacy concerns. Inherence factors pose a greater risk
        than the previous cases because, for example, a biometric characteristic \ul{cannot be
          replaced when compromised}. For this reason, inherence factors should be limited to very secure environments,
        typically used only for local authentication, as a mechanism to unlock a secret or a device.
\end{itemize}


\section{Digital authentication model (NIST SP800.63B)}

% Image from slide
% \begin{figure}[h]
%   \centering
%   \includegraphics[page = 6,trim = 1cm 2.1cm 1cm 3.8cm, clip, width = 0.50\textwidth]{\slides}
%    \caption{General model for digital authentication as described in NIST SP800.63B}
% \end{figure}

\begin{figure}[h]
  \centering
  \includegraphics[width = 0.70\textwidth]{chapter3/NIST_sp800_63b.png}
  \caption{General model for digital authentication as described in
    NIST SP800.63B}
\end{figure}

\begin{itemize}
  \item In this model, an actor who wants to use a system
        is called an \colorbox{LimeGreen}{\textbf{applicant}}: if it possesses an
        authenticator it can provide it to the \colorbox{Goldenrod}{\textit{CSP} (Credential Service Provider)}, or it can get one (for example, when a student is enrolled in Politecnico,
        he is given a smart card that works as an
        authenticator). The CSP is that component that will
        issue or enrol user credential and authenticator, and verify and store associated attributes.


        When this procedure is completed successfully, the actor becomes a \colorbox{Cyan}{\textbf{subscriber}}, which is an entity recorded in the authentication system.


  \item Later, when the actor wants to use some network service, typically the actor is called a \colorbox{LimeGreen}{\textbf{claimant}}, because they claim to be a valid user. Typically, an authentication protocol against a \colorbox{Goldenrod}{verifier} is run to verify this claim. When this process ends successfully, the actor becomes
        \colorbox{Cyan}{\textbf{a subscriber}} \textbf{with an open authenticated session} with the \colorbox{Goldenrod}{relying party}, that will request and receive an authN assertion from the Verifier to assess user identity (and attributes).

        The relying party, which requests the actor to be authenticated, is the end application. The verifier may have communication with the CSP to validate the binding between the authenticator used in the authentication protocol and the credential claimed.
\end{itemize}

\subsubsection*{Recap}
\begin{itemize}
  \item \textbf{The credential binds an authenticator to the subscriber via an ID}:
        \begin{itemize}
          \item for example, an X.509 certificate can be considered the credential, as it binds the identity and attributes written inside the certificate with the authenticator. In this case, the authenticator is the private key that the user controls.
        \end{itemize}
  \item \textbf{CSP (Credential Service Provider)}:
        \begin{itemize}
          \item will issue or enrol user credential and authenticator
          \item verify and store associated attributes
        \end{itemize}
  \item \textbf{Verifier}:
        \begin{itemize}
          \item executes an authN protocol to verify possess of a valid
                authenticator and credential
        \end{itemize}
  \item \textbf{Relying party}:
        \begin{itemize}
          \item will request/receive an authN assertion from the Verifier to
                assess user identity (and attributes)
        \end{itemize}
\end{itemize}


These roles may be separate or collapsed together.
Thinking about a \emph{Linux machine} used locally, the enrollment phase involves creating a new user with a username (the credential) and a password (the authenticator). In this scenario, the CSP is the operating system itself, and when a user wants to use a server on this machine, they need to perform login, which is the verifier. The relying party is any software running on that machine that uses the identity as proven by the login service of the operating system.



Another example is the use of Google Identity for different services, such as the Doodle Service to schedule an
appointment. For Doodle, there is an option to use Google or Facebook Credentials. In this case, the relying party
is Doodle, while the verifier (as well as the CSP) is Google or Facebook.


\section{Generic authentication protocol}

\begin{figure}[h]
  \centering
  \includegraphics[page = 8,trim = 0.4cm 3cm 0.4cm 5.5cm, clip, width = 0.55\textwidth]{\slides}
  \caption{Generic authentication protocol}
\end{figure}
Suppose that the user wants to access an application server (Relying Party). In this case, the server will include both the Relying Party and Verifier.
The user has been identified with the User ID and has a secret associated with that User ID.
The server's identifier contains a table with the User ID and the result of the function $f$ applied to the secret. Normally, the secret should never be stored in cleartext; of course, if the function $f$ is the identity function, it means you are storing the secret in cleartext, which is not recommended.

When the user wants to access the service, they receive an \textbf{authentication request}. Initially, they provide the \textbf{User ID}, and then the verifier asks for a \textbf{proof request}; the user replies with the \textbf{proof $ = F(S_{\mathrm{UID}})$}, which is the result of the computation with the function $F$ applied to the user's secret.

In this scenario, several problems need to be addressed:
\begin{itemize}
  \item On the user side, how is the secret stored? How is the secret provided (e.g., if it is a password entered via a keyboard, a keylogger could disclose it)? Is the transmission of the proof secure?
  \item On the server side, how are the secrets related to the user stored? When a proof is received, how is it verified to be the correct proof?
\end{itemize}



\subsection{Passwords (reusable)}

\begin{figure}[h]
  \centering
  \includegraphics[page = 9,trim = 0.4cm 5cm 0.4cm 5.5cm, clip, width = 0.55\textwidth]{\slides}
  \caption{Authentication with password}
\end{figure}


Imagine that the secret is a \textbf{reusable password} (meaning that it is always the same), and the user is identified by their User ID, with the secret being the password associated with that user. On the server side, there is a table containing usernames and passwords in plain text or a function $H$ computed over the password.

Once again, there will be an \textbf{authentication request}, followed by the user sending their \textbf{UID}. Then, a password request is made, and the user responds with \textbf{$P_{\text{UID}}$}.

Assume the network is secure and focus on the verifier's side. The secret is the user's password, and the client creates and transmits the proof, typically using a function $F = I$, which is the identity function. The proof is the password sent in plain text, which is, of course, dangerous.

Now, looking at the server, when the server receives the password, it needs to check if it is correct or not:
\begin{enumerate}
  \item first case: if the function $f$ used to store the password is the \textbf{identity function} ($f = I$), then the proof is the password in cleartext. In this scenario, the server knows all the passwords in plain text, and verifying their correctness is simple. However, it is risky; if someone copies the database, they will gain access to all data.
  \item second case (\ul{the suggested one}): $f$ is not the identity function but a \textbf{one-way hash} (a digest of the password), and the server does not know the password in plain text but only the (unprotected) digest $H_{\mathrm{UID}}$. This means that access control is a bit more complex, as when the proof is received, the hash of the proof is computed and compared with the hash stored in the password database. If the database is stolen, the attacker will not have a copy of the plain-text passwords.
\end{enumerate}


\subsubsection{Problems of reusable passwords}
Password-based authentication is usually convenient for the user, but only if they have to remember just one password, a reusable one. The current situation is unfortunate because in some applications, there is a need for several passwords that cannot be remembered by a person, so they would need to be stored on the user's side, which is a source of insecurity. The \textbf{disadvantages} of password-based authentication are:
\begin{itemize}
  \item \textbf{The user-side password storage}: it could be written on a post-it or on a client-side password manager (also called password wallet), that stores it encrypted typically using only one passphrase;
  \item \textbf{Guessable passwords};
  \item \textbf{Server-side password storage}: the server must know the password in cleartext or an unprotected digest of it (dictionary attack);
  \item \textbf{Sniffing}: Password can be sniffed while it is sent across the network;
  \item \textbf{DB attacks}: There could be attacks to the password DB at the verifier (if DB contains plaintext or only obfuscated password);
  \item \textbf{Password guessing}: it is very dangerous if it can be done offline, for example against a list of password hashes;
  \item \textbf{Password enumeration}: if the password is limited in length or character type, or if authN protocol doesn't block;
  \item \textbf{Password duplication}: using the same password for different services, due to user password reuse. This could be a problem because if the user has the same password for a high-security service and for a weaker one, an attacker could discover it on the weaker system and have access to the high-security one;
  \item \textbf{Cryptography aging}: the solution adopted for verifying the secret should not be tied to a specific cryptographic algorithm, because it could be then difficult to adapt to the need for changing the algorithm used, due to new attacks and more computing power;
  \item \textbf{Password capture} via server spoofing and phishing;
  \item \textbf{MITM attacks}.
\end{itemize}



\subsubsection*{Password best practice}
\begin{itemize}
  \item Use a \textbf{mixture} of alphabetic characters (both uppercase and lowercase), digits, and special characters. Unfortunately, there are many systems that don't allow the use of special characters or impose limits on password length.
  \item Use a \textbf{long} password, preferably at least 8 characters in length.
  \item \textbf{Avoid using dictionary words}, as attackers often employ dictionaries from multiple languages.
  \item \textbf{Change your password frequently}. If the same password is kept for an extended period, attackers have more time to perform their computations. It's advisable to change your password at least once or twice a year to reduce the window of exposure.
  \item Whenever possible, \textbf{consider not using passwords}. However, this may be unavoidable unless biometric techniques are employed.
\end{itemize}

\subsubsection*{Storing passwords}
\paragraph*{Storing passwords on the server-side}
\begin{itemize}
  \item Never store passwords in cleartext.
  \item If the password is \textbf{encrypted}, the server must have access to the encryption key in cleartext, which can be a security concern. To enhance security, it's recommended to \textbf{store a password digest}. However, be cautious of dictionary attacks that can be expedited by techniques such as \textbf{rainbow tables}. To mitigate these types of attacks, you can introduce an unpredictable element known as a "\textbf{salt}".
\end{itemize}


\subsubsection*{Storing password on the client-side}
\begin{itemize}
  \item Should be only in user's head;
  \item If passwords are a lot, use an encrypted file or a password wallet;
        \ifthenelse{\boolean{showNew}}{
  \item It's better use an encrypted file, or a "password wallet / manager".
        }{}
\end{itemize}

\subsubsection*{Storing passwords on the client-side}
\begin{itemize}
  \item Passwords should be memorized by the user.
  \item If there are numerous passwords to manage, consider using an encrypted file or a password wallet.
\end{itemize}



\subsection{The "Dictionary" Attack}
\begin{figure}[h]
  \centering
  \includegraphics[width = 0.30\textwidth]{chapter3/dictionary_attack.jpg}
\end{figure}

If you store the plain hash of a password, dictionary attacks are possible. This is possible under two hypotheses:
\begin{enumerate}
  \item known hash algorithm;
  \item leakage of information, so that the attacker has a copy of the \textbf{password hash values}.
\end{enumerate}
Hashes are not invertible functions, but it is possible to make a \textbf{pre-computation}. Therefore, even if there is no copy of any password hash yet, it is possible to decide that it would be worthwhile to attack passwords stored as plain SHA-1 hashes in the future.

You must obtain a dictionary containing not only the Italian language but all possible languages.
For each word in the dictionary, you compute the hash of the word and store it in a database paired with the corresponding word.
By "word," we mean a potential passphrase, not a part of it.
Typically, attackers have dictionaries extended to include words such as names of famous people.


The main hypothesis is that the user has chosen one of the words contained in the dictionary. The attack proceeds as follows:
\begin{enumerate}
  \item At some point, the attacker obtains a hash value due to a leakage.
  \item The attacker performs a simple \textbf{lookup} as follows:
        \( w = \mathrm{lookup}(\mathrm{DB}, \mathrm{HP}) \),
        where DB is the database
        and HP is the computed hash of a word in the database, if any of the hash passwords appears in any tuple.
  \item If the response is positive, the password is equal to that word. If not, the password is not from the dictionary.
\end{enumerate}

\textbf{Pre-computation} is the key because if you wait until you get a copy of the password hash, and only at that point you start computing all the possible hash values, it could be too late because the password could have changed.

\subsection{Rainbow table}
A dictionary attack can be made faster and more effective by the \textbf{Rainbow table} technique. It is still a \textit{dictionary attack}, \ul{but it involves a trade-off between space and time}. Trying all possible passwords and computing the hash would be fast, but the result would be a huge database. If you have a complete database, the lookup would be fast, but fewer passwords are stored, and a bit more time is taken to compute the password if the corresponding hash is present. This is an improvement because \ul{it makes an exhaustive attack feasible for certain password sets}.

Imagine creating a rainbow table to attack a password that we know contains 12 digits.
The exhaustive attack would require $10^{12}$ rows, which is a huge number of lines containing passwords and the corresponding hash values.
A rainbow table could be used to reduce the number of rows in the database by a factor of 1000. In this way, we get a $10^9$ rows database, where each line represents 1000 passwords. To achieve that, we use the \textbf{reduction function}:
\[
  r: h \Rightarrow p
\]
It is a function $r$ that takes a hash as input and creates one possible password. \textbf{Beware that this is NOT the inverse of the hash ($h^{-1}$)}, because the inverse of the hash does not exist. It is just a mapping function that, from a hash, creates one of the possible passwords of the whole set; in other words, the reduction function is a different function with a \ul{swapped domain and codomain of the hash function}.

For other informations, check \url{https://en.wikipedia.org/wiki/Rainbow_table}.

\paragraph*{Pre-computation}
Then, the pre-computing is the following:

\begin{figure}[h]
  \centering
  \includegraphics[page = 15,trim = 1cm 2.5cm 7cm 13cm, clip, width = 0.55\textwidth]{\slides}
\end{figure}

\begin{enumerate}
  \item Select $10^9$ distinct passwords (the desired size) called $P$.
  \item For each of them, initialize the computation starting from that specific password, and then iterate 1000 times; each time the hash of the current password is computed (called $k$), and then the reduction function is used to go from $k$ to another possible password.
  \item At the end, the password $P$ of the first cycle is stored in the database together with the last computation of the reduction function (called $p$).
  \item Then, the entry implicitly represents all the 1000 passwords tried. Note that there is no more hash to be stored.
\end{enumerate}


\paragraph*{Attack}
Then the attack rises in this way:
\begin{figure}[h]
  \centering
  \includegraphics[page = 16,trim = 1cm 8.2cm 3cm 5cm, clip, width = 0.55\textwidth]{\slides}
\end{figure}

\begin{enumerate}
  \item $\mathrm{HP}$ is the leaked hash of a password;
  \item Start an iteration of at most 1000 times, and each time, the reduction function is used to derive a possible password from the hash value;
  \item Next, search the database to check if there is a row where $p$ (the result of the reduction function) is at the end of the chain. In that case, we found the chain containing that hash; otherwise, a new value $k$ is calculated by performing the password hash;
  \item After finding the chain, the computation of the hash must be done again to identify which hash matches the one we have.
\end{enumerate}

The problem is that since the reduction function is going from a hash to one possible password, there could be
two different hashes that generates the same password, and this is called \textbf{fusion}. Rather than using a reduction
function, a set of n reduction functions is used, one for each reduction step. On internet there are on sale pre-
computed rainbow tables for various hash functions and password sets (e.g., SHA1 for alphanumeric).


This technique is used by various attack programs.


\subsection{Using salt in storing passwords}
The critical point in the previous kind of attack is that the attacker performs pre-computation. Without the rainbow
table and without the database created by the dictionary,
it would take a lot of time. For this reason, \textbf{do not provide the attacker with the information needed for pre-computation},
because it is based on the idea that the attacker may know which is the password (through the dictionary).

\begin{itemize}
  \item Using the following technique, even if it can be possible to guess what a possible password is, the attacker
        does not get the hash table because every time a User ID is created, the system generates a \textbf{salt} that is different for each user.\\
        The salt is a random (unpredictable) and long (increased dictionary complexity) string of bytes.
        Users do not have to memorize the salt, which should contain rarely used or control characters.\\
        Then the hash is computed using the password concatenated with salt:\\
        $\mathrm{HP} = hash(pwd | salt)$;
  \item The verifier stores UID,
        $\mathrm{HP}_{\mathrm{UID}}$ and $salt_{\mathrm{UID}}$.\\
        If someone gets the information in the database, he also gets the salt, but only then the
        computation can start, which will require a lot of time and in the meanwhile the password could have been
        changed. Additionally, there are different HP for users having the same password.
\end{itemize}

This makes the dictionary attacks nearly impossible (including those based on rainbow tables).


\subsubsection*{Example: Passwords in Linux}
Originally stored in \texttt{/etc/passwd}, hashed with a DES-based
hash function named \texttt{crypt()}.
Since \texttt{/etc/passwd} needs to be world-readable (contains
usernames, UID, GID, home, shell, etc.), passwords have been
moved to \texttt{/etc/shadow}, readable only by system processes.
Passwords are stored in the following form - see \texttt{crypt(5)}:

\begin{verbatim}
  $id$salt$hashedpwd
\end{verbatim}
Different hash functions are used depending on the ID, for example:
\begin{itemize}
  \item 1 = MD5, \ldots, 5 = SHA-256, 6 = SHA-512, \ldots
\end{itemize}
If \texttt{\$id\$salt} is absent, the old DES-based hash is used (with
a 12-bit salt, and the password is truncated to 8 characters) - danger!
Some algorithms have adjustable complexity (to counter brute-force attacks).


\begin{casehistory}{The LinkedIn Attack}
  In June 2012, someone was able to copy 6.5 million passwords from LinkedIn, which were unsalted plain SHA-1
  hashes. The person published those hashes on the internet and asked for crowdsourcing, used for cooperative
  password cracking (which means trying to compute SHA-1 hashing of words and looking if someone has a match).
  At least 236,578 passwords were found before Interpol was able to ban the website that published the
  password hashes.

  Note that simultaneously LinkedIn found out that the LinkedIn app for iPad/iPhone was sending in clear sensitive data
  (not relevant to LinkedIn!).
\end{casehistory}

\subsubsection*{Example: Passwords in MySQL}
\textbf{MySQL} is a database where usernames and passwords are stored in the "user" table. MySQL (from v4.1) uses a \textbf{double hash (without salt!)} to store passwords:
\[
  \texttt{SHA-1(SHA-1(password))}
\]
Then, the hex encoding of the result is stored, preceded by * (to distinguish this case from MySQL versions < 4.1). For example, for the password "Superman!!!," the field \texttt{user.password} is
\begin{verbatim}
    user.password = *868E8E4F0E782EAA610A67B01E63EF04817F60005
\end{verbatim}
To verify that this is the double hash of the word, you can use the following command on Linux:
\begin{verbatim}
  $ echo -n "Superman!!!" | sha1sum | xxd -r -p | sha1sum
\end{verbatim}
This is the standard way for MySQL to store passwords, which is not secure. It is advisable to change the standard way MySQL uses to store passwords by using a salted approach.


\section{Strong (peer) authN}
Recently, there has been a growing emphasis on the requirement to move away from standard authentication methods and adopt strong peer authentication. While this is consistently requested in specifications, it is often not formally defined or defined in multiple, potentially confusing ways.



\subsection{ECB Definition for Internet Banking}
According to the European Central Bank (ECB), \ul{strong customer authentication (authN) is a procedure based on the use of two or more of knowledge, ownership, and inherence.} The selected elements must be \ul{mutually independent}, ensuring that the breach of one does not compromise the others. At least one element should be non-reusable and non-replicable (except for inherence), and not capable of being surreptitiously stolen via the Internet. The strong authentication procedure should be designed to protect the confidentiality of the authentication data; for example, if a password is used, it cannot be sent in clear text.



\subsection{PCI-DSS definition for payment with credit cards}
According to PCI-DSS definition, which is for payment with credit cards, starting from v3.2 it requires multi-
factor authentication (MFA) for access into the cardholder data environment (CDE): it does not matter if it
a trusted or untrusted network, and it is also used when the access is performed by administrators. The only
exception is with direct console access (physical security), which means that you enter the room where the server is placed. For remote access it is always required from untrusted network and by users and third-parties (such as maintenance).
This was the best practise until Jan '18 and it has been made compulsory afterwards.
\textbf{Remember}: MFA is \textbf{not} twice the same factor (e.g., two passwords).


\subsection{PCI-DSS Definition for Payment with Credit Cards}
According to the PCI-DSS definition, which applies to payment with credit cards, starting from v3.2, multi-factor authentication (MFA) is required for access into the cardholder data environment (CDE). This requirement is applicable regardless of whether the network is trusted or untrusted, and it is also mandatory for administrators accessing the CDE. 

The only exception is for direct console access, which involves physical security measures, such as entering the room where the server is located. However, for remote access, MFA is always required, especially from untrusted networks, and for users and third parties (e.g., maintenance).

This best practice was in effect until January '18 and became mandatory thereafter.

\textbf{Remember}: MFA does \textbf{not} mean using the same factor twice, like using two passwords.



\subsection{Other definitions}
According to the \textit{Handbook of Applied Cryptography},\\
authentication is a \textbf{cryptographic challenge-response identification protocol}. 

More in general, it is a technique resisting to a well-defined set of attacks. 

An authN technique can be classified as strong or weak depending on the attack model:
\begin{itemize}
  \item E.g., users of Internet Banking follow the ECB definition;
  \item E.g., employees of PSP adhere to the PCI-DSS definition.
\end{itemize}

In general, pay attention to your specific application field because it defines the types of risks and the level of strength required for your strong authentication.




\section{Challenge-Response Authentication (CRA)}
Challenge-response protocol is a possible way to implement strong authentication. CRA means that there is a
challenge sent to the Claimant from the Verifier. The Claimant replies with the solution computed using some
secret knowledge and the challenge. The Verifier compares the response with a solution computed via a secret
associated with the Claimant.


% Using minipage
\vspace{2mm} 
\noindent
\begin{minipage}{0.5\textwidth}
  \centering
  \includegraphics[page = 25,trim = 0.5cm 2.2cm 1cm 9.8cm, clip, width = \linewidth]{\slides}
\end{minipage}
\hspace{0.05\textwidth}
\begin{minipage}{0.4\textwidth}
  Someone claims to own the identifier (ID). The verifier looks that there is a row
  associated with that ID and sends to the
  claimant the challenge. The claimant has
  a key (\(K_c\)) and uses it to perform some
  kind of computation (function \(f\)) and
  generates a response. The response can
  be checked by applying the function \(g\) to
  the challenge and to a well-known key (\(K_V\)) of the Verifier. The keys can be different or the same.
\end{minipage}


\subsubsection*{General issues of CRA}
\begin{itemize}
  \item \textbf{The challenge must be non-repeatable to avoid replay attacks}. For this reason, usually, the challenge
  is a (random) nonce.
  \item \textbf{The function \(f\) must be non-invertible}, otherwise, a listener can record the traffic and easily find the
  shared secret by using the function \(K_c = f^{-1}(response, challenge)\).
\end{itemize}



\subsection*{Symmetric CRA}

\noindent
\begin{minipage}{0.5\textwidth}
  \centering
  \includegraphics[page = 27,trim = 0.5cm 2.2cm 1cm 9.8cm, clip, width = \linewidth]{\slides}
\end{minipage}
\hspace{0.05\textwidth}
\begin{minipage}{0.4\textwidth}
  In this case, there is a common key
  shared between Claimant and Verifier,
  which is typically the password or
  passphrase of the user. The function \(f\) is computed two times: once from the user
  to make the response, and once from the
  verifier to verify the match. 
\end{minipage}

\subsubsection*{General issues of Symmetric CRA}
General issues with Symmetric CRA are:
\begin{itemize}
  \item The easiest implementation uses a hash function (faster than encryption) such as SHA1 (deprecated),
  SHA2 (recommended) or SHA3 (future);
  \item \(K_{ID}\) must be known in cleartext to the Verifier and this may lead to attacks against the \( \{ID: K_{ID}\} \) table at the Verifier;
\end{itemize}
There is a technique called \textbf{SCRAM} (Salted CRA Mechanism) which solves this problem by using hashed
passwords at the Verifier, which also offers \underline{channel binding} and \underline{mutual authentication}, while we are always talking about single authentication


\subsubsection{Mutual symmetric CRA (v1)}
\noindent
\begin{minipage}{0.4\textwidth}
  Imagine that we are not using a hash but encryption (although it would work in the same way), and let's consider the scenario of mutual authentication.

  Alice and Bob share a key \(K_{AB}\), and Alice sends a message \(A\) to Bob (which means: "Hey, I'm Alice!"). 
  Bob responds with a challenge \(C_B\), 
  and Alice replies with \(\text{enc}(K_{AB}, C_B)\), which is the encryption of the challenge using the shared key. 
  Then, Alice could create a challenge (\(C_A\)), and Bob would respond in the same way by computing \(\text{enc}(K_{AB}, C_A)\). 
  \ul{This approach provides protection against MITM attacks because, if the challenges are nonces, the Replay Attack is not possible.}
  
  \textbf{Beware!} This protocol is outdated and insecure.
\end{minipage}
\hspace{0.05\textwidth}
\begin{minipage}{0.5\textwidth}
  \centering
  \includegraphics[page = 29,trim = 4cm 2.2cm 4cm 9cm, clip, width = \linewidth]{\slides}
\end{minipage}

\subsubsection{Mutual symmetric CRA (v2)}
\vspace*{5mm}
\noindent
\begin{minipage}{0.4\textwidth}
  IBM, in its SNA network system, employed a similar technique with a different implementation: they reduced the number of messages for improved performance without compromising security.

  In the initial step, Alice transmits both the identity (\(A\)) and the challenge (\(C_A\)). The response from Bob includes both the challenge (\(C_B\)) and the encryption \(\text{enc}(K_{AB}, C_A)\). Finally, Alice responds with \(\text{enc}(K_{AB}, C_B)\). Although this may appear equivalent to the previous solution in terms of functionality and security, \underline{it is not}.
  
\end{minipage}
\hspace{0.05\textwidth}
\begin{minipage}{0.5\textwidth}
  \centering
  \includegraphics[page = 30,trim = 4cm 2.2cm 4cm 9cm, clip, width = \linewidth]{\slides}
\end{minipage}




\subsubsection*{Attack to the mutual symmetric CRA (v2)}
\vspace*{5mm}
\noindent
\begin{minipage}{0.4\textwidth}
  Here, Mike pretends to be Alice. Mike sends to Bob Alice's identity (\(A\)) and Alice's challenge (\(C_A\)). Bob replies with \(C_B\) and \(\text{enc}(K_{AB}, C_A)\).
  
  At this point, Mike does not know \(K_{AB}\) and cannot compute the response to the challenge. However, Mike opens a new connection with Bob, sending Alice's identity (\(A\)) again but, this time, sends the challenge sent from Bob (\(C_B\)). Bob replies again with another challenge (\(C_C\)) and \(\text{enc}(K_{AB}, C_B)\), which is the answer to the challenge of the 1st connection. Mike can finally provide the correct answer. 
  
  \ul{Of course, this can be countered if there is a limit on connections}.
\end{minipage}
\hspace{0.05\textwidth}
\begin{minipage}{0.5\textwidth}
  \centering
  \includegraphics[page = 31,trim = 2cm 2.2cm 2cm 4cm, clip, width = \linewidth]{\slides}
\end{minipage}

